#!/usr/bin/env python3
from typing import Union
import numpy as np
from std_msgs.msg import Float64MultiArray
import rospkg
import rospy
from geometry_msgs.msg import Pose, Twist, PoseStamped, Point
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
from robotmpcs.planner.mpcPlanner import MPCPlanner
from mpscenes.goals.goal_composition import GoalComposition
from mpscenes.obstacles.sphere_obstacle import SphereObstacle
from ros_visuals import ROSMarkerPublisher
from sensor_msgs.msg import Joy
import sys
def get_rotation(pose: Pose) -> float:
    orientation_q = pose.orientation
    orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
    (roll, pitch, yaw) = euler_from_quaternion(orientation_list)
    return yaw

class MPCNode():
    _action: np.ndarray
    _cmd_pub: rospy.Publisher
    _rate: rospy.Rate
    _q: np.ndarray
    _qdot: np.ndarray
    _qudot: np.ndarray
    _dt: float
    _r_body: float
    _goal: Union[GoalComposition, None]

    def __init__(self):
        rospy.init_node("mpc_node")
        self._dt = rospy.get_param('/mpc/time_step')
        self._constraints_dict = rospy.get_param('/mpc/constraints')
        self._objectives_dict = rospy.get_param('/mpc/objectives')
        self.vel_topic = rospy.get_param('/ros/vel_topic')
        self.pose_topic = rospy.get_param('/ros/pose_topic')
        self.goal_topic = rospy.get_param('/ros/goal_topic')
        self.establish_ros_connections()
        self._rate = rospy.Rate(1/self._dt)
        self.init_scenario()
        self.init_planner()
        self.set_mpc_parameter()
        self.init_arrays()

        self.keep_output_enabled_for = 0

    def init_scenario(self):
        self._goal = None
        obst1Dict = {
            "type": "sphere",
            "geometry": {"position": [400.0, -1.5, 0.0], "radius": 1.0},
        }
        sphereObst1 = SphereObstacle(name="simpleSphere", content_dict=obst1Dict)
        self._obstacles = [sphereObst1]
        self._r_body = 0.6
        self._limits = np.array([
                [-10, 10],
                [-10, 10],
                [-10, 10],
        ])
        self._limits_u = np.array([
                [-0.5, 0.5],
                [-0.5, 0.5],
                [-0.2, 0.2]
        ])

        self._limits_vel = np.array([
                [-0.5, 0.5],
                [-0.5, 0.5],
                [-0.2, 0.2]
        ])


    def init_arrays(self):
        self._action = np.zeros(3)
        self._q = np.zeros(3)
        self._qudot = np.zeros(3)
        self._qdot = np.zeros(3)

    def init_planner(self):
        self._robot_type = rospy.get_param('/mpc/model_name')
        rospack = rospkg.RosPack()
        self._solver_directory = rospack.get_path("robotmpcs_ros") + "/solvers/"
        self._config = rospy.get_param('/mpc')
        self._planner = MPCPlanner(
            self._robot_type,
            self._solver_directory,
            **self._config)
        self._planner.concretize()
        self._planner.reset()
        self.init_visuals()


    def init_visuals(self):
        self._frame_id = 'map'
        self.marker_publisher = ROSMarkerPublisher("ros_tools/mpc/visuals", 15)

        self._visuals_goal = self.marker_publisher.get_circle(self._frame_id)
        self._visuals_goal.set_color(4, 1.0)
        self._visuals_goal.set_scale(0.5, 0.5, 0.01)
        self._visuals_goal.add_marker(Point(x=10.0, y=0.0, z=2.0))

        self._visuals_goal_angle = self.marker_publisher.get_line(self._frame_id)
        self._visuals_goal_angle.set_color(4, 1.0)
        self._visuals_goal_angle.set_scale(0.1)
        self._visuals_goal_angle.add_line(Point(x=10.0, y=0.0, z=2.0), Point(x=11.0, y=0.0, z=2.0))

        self._visuals_plan_circle = self.marker_publisher.get_circle(self._frame_id)
        self._visuals_plan_circle.set_color(7, 0.5)
        self._visuals_plan_circle.set_scale(0.5, 0.5, 0.01)
        self._visuals_plan_circle.add_marker(Point(x=10.0, y=0.0, z=2.0))

    def set_mpc_parameter(self):
        constraints = self._constraints_dict
        objectives = self._objectives_dict

        for constraint in constraints:
            if constraint == 'JointLimitConstraints':
                try:
                    self._planner.setJointLimits(np.transpose(self._limits))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            elif constraint == 'VelLimitConstraints':
                try:
                    self._planner.setVelLimits(np.transpose(self._limits_vel))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            elif constraint == 'InputLimitConstraints':
                try: self._planner.setInputLimits(np.transpose(self._limits_u))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            elif constraint == 'LinearConstraints':
                try: self._planner.setLinearConstraints(self._lin_constr, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            elif constraint == 'RadialConstraints':
                try: self._planner.setRadialConstraints(self._obstacles, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            elif constraint == 'SelfCollisionAvoidanceConstraints':
                try: self._planner.setSelfCollisionAvoidanceConstraints(self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
                    sys.exit(1)
            else:
                print('No function to set the parameters for this constraint type is defined')
                sys.exit(1)



    def establish_ros_connections(self):
        self._cmd_pub = rospy.Publisher(
            self.vel_topic, Twist, queue_size=1
        )
        self._odom_sub = rospy.Subscriber(
            self.pose_topic, Odometry, self._odom_cb
        )
        self._goal_sub = rospy.Subscriber(
            self.goal_topic, PoseStamped, self._goal_cb
        )

        self.joystick_sub = rospy.Subscriber('/bluetooth_teleop/joy', Joy, self.joystick_cb, queue_size=1)


    def _goal_cb(self, goal_msg: Float64MultiArray):
        goal_position = [goal_msg.pose.position.x, goal_msg.pose.position.y]
        if len(goal_position) != 2:
            rospy.logwarn("Goal ignored because of dimension missmatch")
        goal_dict = {
            "subgoal0": {
                "weight": 1.0,
                "is_primary_goal": True,
                "indices": [0, 1],
                "parent_link": 'origin',
                "child_link": rospy.get_param('/robot/end_link'),
                "desired_position": goal_position,
                "angle": [0,0,0,1],
                "epsilon": 0.4,
                "type": "staticSubGoal"
            }
        }
        self._goal = GoalComposition(name="goal1", content_dict=goal_dict)
        self._planner.setGoalReaching(self._goal)


    def _odom_cb(self, odom_msg: Odometry):
        self._q = np.array([
            odom_msg.pose.pose.position.x,
            odom_msg.pose.pose.position.y,
            get_rotation(odom_msg.pose.pose),
        ])
        self._qdot = np.array([
            odom_msg.twist.twist.linear.x,
            odom_msg.twist.twist.linear.y,
            odom_msg.twist.twist.angular.z,
        ])

    def joystick_cb(self, msg):
        # This is used as a safety command for the real robot
        if msg.axes[2] <= -0.9: # press L2 on ps4 controller
            self.enable_output = True
            self.keep_output_enabled_for = 2 # budget of two to prevent race condition
        else:
            self.keep_output_enabled_for = 0

    def actuate_if_deadman_switch(self):
        if self.keep_output_enabled_for > 0:
            self.enable_output = True
            self.keep_output_enabled_for -= 1
            # Publish output command
            self._cmd_pub.publish(self.vel_cmd_msg)
        else:
            self.enable_output = False

    def act(self):
        vel_action = self._action
        self.vel_cmd_msg = Twist()
        self.vel_cmd_msg.linear.x = 0.1#vel_action[1]
        self.vel_cmd_msg.linear.y = -0.1#vel_action[0]

        self.actuate_if_deadman_switch()
        #self._qudot = vel_action

    def run(self):
        while not rospy.is_shutdown():
            if self._goal:
                self._planner.setGoalReaching(self._goal)
                print("q: " + str(self._q))
                print("goal: " + str(self._goal))
                self._action, output, exitflag, vel_limit = self._planner.computeAction(self._q, self._qdot)
                for i in range(output.shape[0]):
                    position = Point(x=output[i,0], y=output[i,1], z=0.1)
                    self._visuals_plan_circle.add_marker(position)


                #rospy.loginfo(self._action)
                if self._action[0]>vel_limit:
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            self.act()
            self.marker_publisher.publish()
            self._rate.sleep()

if __name__ == "__main__":
    try:
        mpc_node = MPCNode()
        mpc_node.run()
    except rospy.ROSInterruptException:
        pass
    
