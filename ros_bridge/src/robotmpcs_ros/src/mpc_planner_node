#!/usr/bin/env python3
from typing import Union, Tuple,List
import numpy as np
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import PointCloud2
import rospkg
import sys
import rospy
import tf
import tf2_ros
import sensor_msgs.point_cloud2 as pc2
from geometry_msgs.msg import Pose, Twist
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
import tf2_sensor_msgs
from ros_bridge.src.robotmpcs_ros.utils.ros_visuals import ROSMarkerPublisher
from robotmpcs.planner.mpcPlanner import MPCPlanner
from mpscenes.goals.goal_composition import GoalComposition
from mpscenes.obstacles.sphere_obstacle import SphereObstacle
from robotmpcs.utils.free_space_decomposition import FreeSpaceDecomposition

def get_rotation(pose: Pose) -> float:
    orientation_q = pose.orientation
    orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
    (roll, pitch, yaw) = euler_from_quaternion(orientation_list)
    return yaw

class MPCNode():
    _action: np.ndarray
    _cmd_pub: rospy.Publisher
    _rate: rospy.Rate
    _q: np.ndarray
    _qdot: np.ndarray
    _qudot: np.ndarray
    _dt: float
    _r_body: float
    _goal: Union[GoalComposition, None]

    def __init__(self):
        rospy.init_node("mpc_node")
        self.tf_buffer = tf2_ros.Buffer()
        self.establish_ros_connections()
        self._dt = rospy.get_param('/mpc/time_step')
        self._rate = rospy.Rate(1/self._dt)
        self.init_scenario()
        self.init_planner()
        self.set_mpc_parameter()
        self.init_arrays()
        self.init_visuals()
        self.listener = tf.TransformListener()
        self._translation = [0,0,0]
        self._rotation= [0,0,0,1]


    def init_scenario(self):
        self._goal = None
        self._lidar_pointcloud = None
        obst1Dict = {
            "type": "sphere",
            "geometry": {"position": [400.0, -1.5, 0.0], "radius": 1.0},
        }
        sphereObst1 = SphereObstacle(name="simpleSphere", content_dict=obst1Dict)
        self._obstacles = [sphereObst1]
        self._r_body = 0.6
        self._limits = np.array([
                [-10, 10],
                [-10, 10],
                [-10, 10],
        ])
        self._limits_u = np.array([
                [-10, 10],
                [-10, 10],
        ])
    def init_visuals(self):
        self.constr_color = 0

        self.visuals = ROSMarkerPublisher('/mpc_planner_node/visuals', 100)

        self.visual_constraints = self.visuals.get_line('odom')
        self.visual_constraints.set_scale(0.05)
        self.visual_constraints.set_color(self.constr_color)

        self.visual_goal = self.visuals.get_circle('odom')
        self.visual_goal.set_scale(0.4,0.4,0.01)
        self.visual_goal.set_color(1)

    def init_arrays(self):
        self._action = np.zeros(2)
        self._q = np.zeros(3)
        self._qudot = np.zeros(2)
        self._qdot = np.zeros(3)

    def init_planner(self):
        self._robot_type = rospy.get_param('/mpc/model_name')
        rospack = rospkg.RosPack()
        self._solver_directory = rospack.get_path("robotmpcs_ros") + "/solvers/"
        self._config = rospy.get_param('/mpc')
        self._N = self._config['time_horizon']
        self._n_obstacles = self._config['number_obstacles']
        self._fsd = FreeSpaceDecomposition(number_constraints=self._n_obstacles, max_radius=5)
        self._planner = MPCPlanner(
            self._robot_type,
            self._solver_directory,
            **self._config)
        self._planner.concretize()
        self._planner.reset()

    def set_mpc_parameter(self):
        constraints = self._config['constraints']
        objectives = self._config['objectives']

        for objective in objectives:
            if objective == 'GoalReaching':
                try:
                    self._planner.setGoalReaching(self._goal)
                except AttributeError:
                    print('The required attributes for setting ' + objective + ' are not defined')
            elif objective == 'ConstraintAvoidance':
                try:
                    self._planner.setConstraintAvoidance()
                except KeyError:
                    print('The required attributes for setting ' + objective + ' are not defined in the config file')
            else:
                print('No function to set the parameters for this objective is defined')


        for constraint in constraints:
            if constraint == 'JointLimitConstraints':
                try:
                    self._planner.setJointLimits(np.transpose(self._limits))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'VelLimitConstraints':
                try:
                    self._planner.setVelLimits(np.transpose(self._limits_vel))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'InputLimitConstraints':
                try:
                    self._planner.setInputLimits(np.transpose(self._limits_u))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'LinearConstraints':
                try:
                    self._planner.setLinearConstraints(self._lin_constr, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'RadialConstraints':
                try:
                    self._planner.setRadialConstraints(self._obstacles, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'SelfCollisionAvoidanceConstraints':
                try:
                    self._planner.setSelfCollisionAvoidanceConstraints(self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            else:
                print('No function to set the parameters for this constraint type is defined')

    def establish_ros_connections(self):
        self._cmd_pub = rospy.Publisher(
            "/boxer_velocity_controller/cmd_vel", Twist, queue_size=1
        )
        self._odom_sub = rospy.Subscriber(
            "/odometry/filtered", Odometry, self._odom_cb
        )
        self._goal_sub = rospy.Subscriber(
            "/mpc/goal", Float64MultiArray, self._goal_cb
        )

        self._lidar_sub = rospy.Subscriber(
            "/merged_cloud", PointCloud2, self._lidar_cb
        )

    def _goal_cb(self, goal_msg: Float64MultiArray):
        goal_position = goal_msg.data
        if len(goal_position) != 2:
            rospy.logwarn("Goal ignored because of dimension missmatch")
        goal_dict = {
            "subgoal0": {
                "weight": 1.0,
                "is_primary_goal": True,
                "indices": [0, 1],
                "parent_link": 'origin',
                "child_link": rospy.get_param('/robot/end_link'),
                "desired_position": goal_position,
                "epsilon": 0.4,
                "type": "staticSubGoal"
            }
        }
        self._goal = GoalComposition(name="goal1", content_dict=goal_dict)
        self._planner.setGoalReaching(self._goal)


    def _odom_cb(self, odom_msg: Odometry):
        self._q = np.array([
            odom_msg.pose.pose.position.x,
            odom_msg.pose.pose.position.y,
            get_rotation(odom_msg.pose.pose),
        ])
        self._qdot = np.array([
            odom_msg.twist.twist.linear.x,
            odom_msg.twist.twist.linear.y,
            odom_msg.twist.twist.angular.z,
        ])

    def _lidar_cb(self, msg: PointCloud2):
        print(msg.header.frame_id)

        while True:
            point_cloud_array = []
            try:
                # Transform the PointCloud2 to the desired frame

                transform = self.tf_buffer.lookup_transform('odom', msg.header.frame_id, rospy.Time(0))

                #self._translation = transform.transform.translation
                print('transform')
                print(transform)
                break

                #cloud_points = np.array(list(pc2.read_points(msg)))

                #transformed_points = np.dot(cloud_points[:, :3], np.transpose([transform.transform.rotation.x,
                #                                                               transform.transform.rotation.y,
                #                                                               transform.transform.rotation.z,
                 #                                                              transform.transform.rotation.w]))
                #transformed_points += [transform.transform.translation.x,
                #                       transform.transform.translation.y,
                #                       transform.transform.translation.z]
                #print('transformed')


            except Exception as e:
                rospy.logwarn(f"Could not transform the lidar PointCloud {e}")
                # Print additional information for debugging
                print(f"Source frame: {msg.header.frame_id}")
                print(f"Target frame: odom")
                print(f"TF tree:\n{self.tf_buffer.all_frames_as_string()}")
                self._rate.sleep()



        # Use pc2.read_points to iterate through the PointCloud2 message

        # Now, point_cloud_array contains the array of points from the PointCloud2 message
        # Use this array for further processing or manipulation
        # Example: print the first 5 points
        transformed_cloud = tf2_sensor_msgs.do_transform_cloud(msg, transform)
        for point in pc2.read_points(transformed_cloud, field_names=("x", "y", "z"), skip_nans=True):
             point_cloud_array.append([point[0], point[1], point[2]])  # Extract x, y, z coordinates
        self._lidar_pointcloud = np.array(point_cloud_array)


    def compute_constraints(self, robot_state: np.ndarray, point_cloud: np.ndarray) -> Tuple[List, List]:
        """
        Computes linear constraints given a pointcloud as numpy array.
        The seed point is the robot_state.
        """
        angle = robot_state[2]
        rot_matrix = np.array([
                [np.cos(angle), -np.sin(angle)],
                [np.sin(angle), np.cos(angle)],
        ])

        position_lidar = np.dot(rot_matrix, np.array([0.4, 0.0])) + self._translation[:2]

        lidar_position = np.array([position_lidar[0], position_lidar[1], self._translation[2]])

        self._fsd.set_position(lidar_position)
        if len(point_cloud)>0:
            self._fsd.compute_constraints(point_cloud)
        return list(self._fsd.asdict().values()), self._fsd.constraints()

    def act(self):
        vel_action = self._action * self._dt + self._qudot
        cmd_msg = Twist()
        cmd_msg.linear.x = vel_action[0]
        cmd_msg.angular.z = vel_action[1]
        self._cmd_pub.publish(cmd_msg)
        self._qudot = vel_action

    def run(self):
        while not rospy.is_shutdown():
            linear_constraints = []
            if self._lidar_pointcloud is not None:
                halfplanes = []
                for j in range(self._N):
                    if not self._output is None and self._exitflag >= 0:
                        key = "x{:02d}".format(j + 1)
                        ref_q = self._output[key][0:3]
                    else:
                        ref_q = self._q
                    linear_constraints_j, halfplanes_j = self.compute_constraints(ref_q, self._lidar_pointcloud)
                    linear_constraints.append(linear_constraints_j)
                    halfplanes.append(halfplanes_j)

                self._planner.setLinearConstraints(linear_constraints, r_body=self._r_body)
            if self._goal:
                self._action, self._output, self._exitflag = self._planner.computeAction(self._q, self._qdot, self._qudot)
            rospy.loginfo(self._action)
            self.act()
            if self.check_goal_reaching(self._q):
                print('GOAL REACHED')

            self.visualize(linear_constraints)
            self._rate.sleep()

    def visualize(self,linear_constraints):
        if len(linear_constraints)>0:
            for constraint in linear_constraints[0]:
                self.visual_constraints.add_constraint_line(constraint[:2], -constraint[-1], length=10.0)

        if self._goal is not None:
            goal_pose = Pose()
            print(self._goal.primary_goal())
            goal_pose.position.x = self._goal.primary_goal().position()[0]
            goal_pose.position.y = self._goal.primary_goal().position()[1]
            goal_pose.position.z = 0.01
            self.visual_goal.add_marker(goal_pose)
        self.visuals.publish()

    def check_goal_reaching(self, q):
        if self._goal is not None:
            primary_goal = self._goal.primary_goal()
            goal_dist = np.linalg.norm(q[:2] - primary_goal.position()) # todo remove hard coded dimension, replace it with fk instead
            if goal_dist <= primary_goal.epsilon():
                return True
            return False
        return False

if __name__ == "__main__":
    try:
        mpc_node = MPCNode()
        mpc_node._output: Union[dict, None] = None
        mpc_node.run()
    except rospy.ROSInterruptException:
        pass
    
